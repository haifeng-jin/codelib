.
./update.sh
./book.txt
./discretization.cpp
int get_index(int a)
{
	return lower_bound(discrete, discrete + discrete_num, a) - discrete;
}

void discretization(int discrete[], int &discrete_num)
{
	sort(discrete, discrete + discrete_num);
	discrete_num = unique(discrete, discrete + discrete_num) - discrete;
}
./clean.sh
./grid move
./grid move/grid_move.cpp
struct Point
{
	int x, y;
	Point()
	{}
	Point(int x, int y):x(x), y(y)
	{}
	Point operator + (const Point &a)
	{
		return Point(x + a.x, y + a.y);
	}
};

Point dir[4] = {Point(1, 0), Point(0, 1), Point(-1, 0), Point(0, -1)};
bool vis[MAX_X][MAX_Y];
int row_num, col_num;
char dir_name[] = "DRUL";
int grid[MAX_X][MAX_Y];

void visit(Point a)
{
	vis[a.x][a.y] = true;
}

bool out(Point a)
{
	return a.x < 0 || a.y < 0 || a.x >= row_num || a.y >= col_num;
}

bool visited(Point a)
{
	return vis[a.x][a.y];
}
./grid move/grid_move_bfs_pq.cpp
struct Point
{
	int x, y;
	int time;
	Point()
	{}
	Point(int x, int y):x(x), y(y)
	{}
	Point(int x, int y, int t): x(x), y(y), time(t)
	{}
	Point operator + (const Point &a)
	{
		return Point(x + a.x, y + a.y);
	}
	bool operator < (const Point &a) const
	{
		return time > a.time;
	}
	bool operator == (const Point &a) const
	{
		return x == a.x && y == a.y;
	}
};

Point dir[4] = {Point(1, 0), Point(0, 1), Point(-1, 0), Point(0, -1)};
bool vis[MAX_X][MAX_Y];
int dis[MAX_X][MAX_Y];
int row_num, col_num;
char dir_name[] = "DRUL";
char dir_name2[] = "SENW";
char grid[MAX_X][MAX_Y];
Point start, end;

void visit(Point a)
{
	vis[a.x][a.y] = true;
}

bool out(Point a)
{
	return a.x < 0 || a.y < 0 || a.x >= row_num || a.y >= col_num;
}

bool visited(Point a)
{
	return vis[a.x][a.y];
}

void input()
{
	scanf("%d", &row_num);
	col_num = row_num;
	for (int i = 0; i < row_num; i++)
	{
		scanf("%s", grid[i]);
	}
	for (int i = 0; i < row_num; i++)
	{
		for (int j = 0; j < col_num; j++)
		{
			if (grid[i][j] == 'M')
			{
				start = Point(i, j);
				grid[i][j] = '.';
			}
			if (grid[i][j] == 'T')
			{
				end = Point(i, j);
				grid[i][j] = '.';
			}
		}
	}
}

void init()
{
	for (int i = 0; i < row_num; i++)
	{
		for (int j = 0; j < col_num; j++)
		{
			vis[i][j] = false;
			dis[i][j] = INF;
		}
	}
}

int bfs()
{
	init();
	priority_queue<Point> pq;
	start.time = 0;
	pq.push(start);
	while (!pq.empty())
	{
		Point u = pq.top();
		pq.pop();
		if (u == end)
		{
			return u.time;
		}
		if (visited(u))
		{
			continue;
		}
		visit(u);
		for (int i = 0; i < 4; i++)
		{
			Point v = u + dir[i];
			if (out(v) || grid[v.x][v.y] != '.')
			{
				continue;
			}
			if (u.time + 1 < dis[v.x][v.y])
			{
				dis[v.x][v.y] = u.time + 1;
				pq.push(Point(v.x, v.y, u.time + 1));
			}
		}
	}
	return -1;
}

./DFA
./DFA/ac_automation.cpp
//1.init() 2.insert() 3.build() 4.query()
struct Trie
{
	int next[MAX_NODE_NUM][MAX_CHILD_NUM];
	int fail[MAX_NODE_NUM];
	int count[MAX_NODE_NUM];
	int node_cnt;
	bool vis[MAX_NODE_NUM]; //set it to false
	int root;

	void init()
	{
		node_cnt = 0;
		root = newnode();
		memset(vis, 0, sizeof(vis));
	}

	int newnode()
	{
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			next[node_cnt][i] = -1;
		count[node_cnt++] = 0;
		return node_cnt - 1;
	}

	int get_id(char a)
	{
		return a - 'A';
	}

	void insert(char buf[])
	{
		int now = root;
		for (int i = 0; buf[i]; i++)
		{
			int id = get_id(buf[i]);
			if (next[now][id] == -1)
				next[now][id] = newnode();
			now = next[now][id];
		}
		count[now]++;
	}

	void build()
	{
		queue<int>Q;
		fail[root] = root;
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			if (next[root][i] == -1)
				next[root][i] = root;
			else
			{
				fail[next[root][i]] = root;
				Q.push(next[root][i]);
			}
		while (!Q.empty())
		{
			int now = Q.front();
			Q.pop();
			for (int i = 0; i < MAX_CHILD_NUM; i++)
				if (next[now][i] == -1)
					next[now][i] = next[fail[now]][i];
				else
				{
					fail[next[now][i]]=next[fail[now]][i];
					Q.push(next[now][i]);
				}
		}
	}

	int query(char buf[])
	{
		int now = root;
		int res = 0;

		memset(vis, 0, sizeof(vis));
		for (int i = 0; buf[i]; i++)
		{
			now = next[now][get_id(buf[i])];
			int temp = now;
			while (temp != root && !vis[temp])
			{
				res += count[temp];
 				// optimization: prevent from searching this fail chain again.
				//also prevent matching again.
				vis[temp] = true;
				temp = fail[temp];
			}
		}
		return res;
	}

	void debug()
	{
		for(int i = 0;i < node_cnt;i++)
		{
			printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],count[i]);
			for(int j = 0;j < MAX_CHILD_NUM;j++)
				printf("%2d",next[i][j]);
			printf("]\n");
		}
	}
};


./DFA/ac_automation_matrix.cpp
struct Trie
{
	int next[MAX_NODE_NUM][MAX_CHILD_NUM];
	int fail[MAX_NODE_NUM];
	int count[MAX_NODE_NUM];
	int node_cnt;
	bool vis[MAX_NODE_NUM]; //set it to false
	int root;

	void init()
	{
		node_cnt = 0;
		root = newnode();
		memset(vis, 0, sizeof(vis));
	}

	int newnode()
	{
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			next[node_cnt][i] = -1;
		count[node_cnt++] = 0;
		return node_cnt - 1;
	}

	int get_id(char a)
	{
		return a - 'A';
	}

	void insert(char buf[])
	{
		int now = root;
		for (int i = 0; buf[i]; i++)
		{
			int id = get_id(buf[i]);
			if (next[now][id] == -1)
				next[now][id] = newnode();
			now = next[now][id];
		}
		count[now]++;
	}

	void build()
	{
		queue<int>Q;
		fail[root] = root;
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			if (next[root][i] == -1)
				next[root][i] = root;
			else
			{
				fail[next[root][i]] = root;
				Q.push(next[root][i]);
			}
		while (!Q.empty())
		{
			int now = Q.front();
			Q.pop();
			for (int i = 0; i < MAX_CHILD_NUM; i++)
				if (next[now][i] == -1)
					next[now][i] = next[fail[now]][i];
				else
				{
					fail[next[now][i]]=next[fail[now]][i];
					Q.push(next[now][i]);
				}
		}
	}

	int query(char buf[])
	{
		int now = root;
		int res = 0;

		memset(vis, 0, sizeof(vis));
		for (int i = 0; buf[i]; i++)
		{
			now = next[now][get_id(buf[i])];
			int temp = now;
			while (temp != root && !vis[temp])
			{
				res += count[temp];
 				// optimization: prevent from searching this fail chain again.
				//also prevent matching again.
				vis[temp] = true;
				temp = fail[temp];
			}
		}
		return res;
	}

	void debug()
	{
		for(int i = 0;i < node_cnt;i++)
		{
			printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],count[i]);
			for(int j = 0;j < MAX_CHILD_NUM;j++)
				printf("%2d",next[i][j]);
			printf("]\n");
		}
	}
}ac;

struct Matrix
{
	int order;
	int num[MAX_MATRIX_SIZE][MAX_MATRIX_SIZE];

	Matrix()
	{}

	Matrix(int ord)
	{
		order = ord;
	}

	void init()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				num[i][j] = 0;
			}
		}
	}
	void output()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				printf("%d ", num[i][j]);
			}
			puts("");
		}
	}
};

Matrix operator*(Matrix ma, Matrix mb)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	int i, j, k;
	for (i = 0; i < ord; i++)
	{
		for (k = 0; k < ord; k++)
		{
			if (ma.num[i][k] == 0)
				continue;
			for (j = 0; j < ord; j++)
			{
				long long temp = ma.num[i][k] * (long long)mb.num[k][j];
				temp %= MOD;
				numc.num[i][j] += temp;
				numc.num[i][j] %= MOD;
			}
		}
	}
	return numc;
}

Matrix matrix_power(Matrix ma, int x)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	for (int i = 0; i < ord; i++)
	{
		numc.num[i][i] = 1;
	}
	for (; x; x >>= 1)
	{
		if (x & 1)
		{
			numc = numc * ma;
		}
		ma = ma * ma;
	}
	return numc;
}

void extract_matrix(Matrix &matrix)
{
	matrix.order = ac.node_cnt;
	matrix.init();
	for (int i = 0; i < ac.node_cnt; i++)
	{
		for (int j = 0; j < MAX_CHILD_NUM; j++)
		{
			if (ac.next[i][j] == NULL)
				continue;
			int temp = ac.next[i][j];
			if (ac.count[temp] == 0)
			{
				matrix.num[i][temp] += 1;
			}
		}
	}
}

./RMQ&LCA
./RMQ&LCA/LCA_online_bfs.cpp
#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define MAX_Q_LEN MAX_NODE_NUM
#define M 30

struct Edge
{
	int v, next, id;
	Edge()
	{}
	Edge(int v, int next, int id):v(v), next(next), id(id)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int id)
{
	edge[edge_cnt] = Edge(v, head[u], id);
	head[u] = edge_cnt++;
}

bool vis[MAX_NODE_NUM];
int father[MAX_NODE_NUM][M];
int depth[MAX_NODE_NUM];

template<typename T>
class queue
{
	T data[MAX_Q_LEN];
	int head, tail;

public:
	queue()
	{
		head = tail = 0;
	}

	bool empty()
	{
		return head == tail;
	}

	void pop()
	{
		head++;
		if (head >= MAX_Q_LEN)
			head = 0;
	}

	void push(T a)
	{
		data[tail++] = a;
		if (tail >= MAX_Q_LEN)
			tail = 0;
	}

	T front()
	{
		return data[head];
	}
};

void bfs(int root)
{
	queue<int> q;
	q.push(root);
	seq2_cnt = 0;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		vis[u] = true;
		seq2[seq2_cnt++] = u;
		for (int i = head[u]; i != -1; i = edge[i].next)
		{
			int v = edge[i].v;
			if (vis[v])
			{
				continue;
			}
			father[v][0] = u;
			depth[v] = depth[u] + 1;
			q.push(v);
		}
	}
}

//index start from 1.
void init_LCA(int root)
{
	fill_n(vis, node_num + 1, 0);
	memset(father, 0, sizeof(father));
	bfs(root);
	bool did;
	for (int i = 1; i < M; i++)
	{
		did = false;
		for (int j = 1; j <= node_num; j++)
		{
			int k = father[j][i - 1];
			if (k <= 0)
			{
				continue;
			}
			father[j][i] = father[k][i - 1];
			did = true;
		}
		if (!did)
		{
			break;
		}
	}
}

//O(log(n))
int LCA(int x, int y)
{
	if (depth[x] > depth[y])
	{
		swap(x, y);
	}
	int diff = depth[y] - depth[x];
	for (int i = 0; i < M && diff; i++)
	{
		if (diff & 1)
		{
			y = father[y][i];
		}
		diff >>= 1;
	}
	if (x == y)
	{
		return x;
	}
	int exp = 0;
	while (x != y)
	{
		if (!exp || father[x][exp] != father[y][exp])
		{
			x = father[x][exp];
			y = father[y][exp];
			exp++;
		}else
		{
			exp--;
		}
	}
	return x;
}


./RMQ&LCA/RMQ_ST.cpp
//call init_RMQ(f[], n) first.
//then call query(a, b) to quest the RMQ of [a, b].
int power[30];
int st[MAX_NODE_NUM * 2][32];
int ln[MAX_NODE_NUM * 2];

//returns the index of the first minimum value in [x, y]
void init_RMQ(int f[], int n)
{
	int i, j;
	for (power[0] = 1, i = 1; i < 21; i++)
	{
		power[i] = 2 * power[i - 1];
	}
	for (i = 0; i < n; i++)
	{
		st[i][0] = i;
	}
	ln[0] = -1;
	for (int i = 1; i <= n; i++)
	{
		ln[i] = ln[i >> 1] + 1;
	}
	for (j = 1; j < ln[n]; j++)
	{
		for (i = 0; i < n; i++)
		{
			if (i + power[j - 1] - 1 >= n)
			{
				break;
			}
			//for maximum, change ">" to "<"
			//for the last, change "<" or ">" to "<=" or ">="
			if (f[st[i][j - 1]] > f[st[i + power[j - 1]][j - 1]])
			{
				st[i][j] = st[i + power[j - 1]][j - 1];
			}
			else
			{
				st[i][j] = st[i][j - 1];
			}
		}
	}
}

int query(int x, int y)
{
	if(x > y)
	{
		swap(x, y);
	}
	int k = ln[y - x + 1];
	//for maximum, change ">" to "<"
	//for the last, change "<" or ">" to "<=" or ">="
	if (depth[st[x][k]] > depth[st[y - power[k] + 1][k]])
		return st[y - power[k] + 1][k];
	return st[x][k];
}
./RMQ&LCA/LCA_online_dfs.cpp
//first call init_LCA(root).
//then call LCA(a, b) to quest the LCA of a and b.
//the graph can be both bidirected or unidirected.
#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define M 30

struct Edge
{
	int v, next, id;
	Edge()
	{}
	Edge(int v, int next, int id):v(v), next(next), id(id)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int id)
{
	edge[edge_cnt] = Edge(v, head[u], id);
	head[u] = edge_cnt++;
}

bool vis[MAX_NODE_NUM];
int father[MAX_NODE_NUM];
int power[M];
int st[MAX_NODE_NUM * 2][M];
int ln[MAX_NODE_NUM * 2];
int seq_cnt;
int seq[2*MAX_NODE_NUM];
int depth[2*MAX_NODE_NUM];
int first_appearance[MAX_NODE_NUM];

//returns the index of the first minimum value in [x, y]
void init_RMQ(int f[], int n)
{
	int i, j;
	for (power[0] = 1, i = 1; i < 21; i++)
	{
		power[i] = 2 * power[i - 1];
	}
	for (i = 0; i < n; i++)
	{
		st[i][0] = i;
	}
	ln[0] = -1;
	for (int i = 1; i <= n; i++)
	{
		ln[i] = ln[i >> 1] + 1;
	}
	for (j = 1; j < ln[n]; j++)
	{
		for (i = 0; i < n; i++)
		{
			if (i + power[j - 1] - 1 >= n)
			{
				break;
			}
			//for maximum, change ">" to "<"
			//for the last, change "<" or ">" to "<=" or ">="
			if (f[st[i][j - 1]] > f[st[i + power[j - 1]][j - 1]])
			{
				st[i][j] = st[i + power[j - 1]][j - 1];
			}
			else
			{
				st[i][j] = st[i][j - 1];
			}
		}
	}
}

int query(int x, int y)
{
	if(x > y)
	{
		swap(x, y);
	}
	int k = ln[y - x + 1];
	//for maximum, change ">" to "<"
	//for the last, change "<" or ">" to "<=" or ">="
	if (depth[st[x][k]] > depth[st[y - power[k] + 1][k]])
		return st[y - power[k] + 1][k];
	return st[x][k];
}


void dfs(int u ,int current_depth)
{
	vis[u] = true;
	first_appearance[u] = seq_cnt;
	depth[seq_cnt] = current_depth;
	seq[seq_cnt++] = u;
	for(int i = head[u]; i != -1; i = edge[i].next)
	{
		int v = edge[i].v;
		if (vis[v])
		{
			continue;
		}
		father[v] = u;
		if (!vis[v])
		{
			dfs(v, current_depth + 1);
			depth[seq_cnt] = current_depth;
			seq[seq_cnt++] = u;
		}
	}
}

void init_LCA(int root)
{
	memset(vis, 0, sizeof(vis));
	father[root] = -1;
	seq_cnt = 0;
	dfs(root, 0);
	init_RMQ(depth, seq_cnt);
}

//O(1)
int LCA(int u ,int v)
{
	int x = first_appearance[u];
	int y = first_appearance[v];
	int res = query(x, y);
	return seq[res];
}


./print.sh
./three_division.cpp
int three_division(int s, int e)
{
	int l = s;
	int r = e;
	while (l < r)
	{
		int len = r - l;
		int lmid = l + len / 3;
		int rmid = r - len / 3;
		if (cal(lmid) > cal(rmid))
		{
			r = rmid - 1;
		}else
		{
			l = lmid + 1;
		}
	}
	return cal(l);
}


./random.cpp
double random_double()
{
	return rand() * 1.0 / RAND_MAX;
}

int random_int(int bound)
{
	return (int) (random_double() * (bound - 1) + 0.5);
}

void init_random()
{
	srand(time(NULL));
}

./number theory
./number theory/prime_sieve.cpp
bool is_prime[MAX_N];
int prime[MAX_N];

int getprime(int n)
{
	int i, j, k = 0;
	int s, e = (int)(sqrt(0.0 + n) + 1);
	memset(is_prime, 1, sizeof(is_prime));
	prime[k++] = 2;
	is_prime[0] = is_prime[1] = 0;
	for (i = 4; i < n; i += 2) 
		is_prime[i] = 0;
	for (i = 3; i < e; i += 2)
		if (is_prime[i])
		{
			prime[k++] = i;
			for (s = i * 2, j = i * i; j < n; j += s)
				is_prime[j] = 0;
		}
	for ( ; i < n; i += 2)
		if (is_prime[i])
			prime[k++] = i;
	return k;
}
./number theory/gcd.cpp
LL gcd(LL a,LL b){
    if (a==0) return 1;
    if (a<0) return gcd(-a,b);
    while (b){
        LL t=a%b; a=b; b=t;
    }
    return a;
}
./number theory/pollard_rho.cpp
typedef long long LL;
#define maxn 10000
const int S = 20;

LL factor[maxn];
int tot;

LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

LL pow_mod(LL x, LL n, LL mod)
{  //返回x^n mod c ,非递归版
	x %= mod;
	if (n == 1)
		return x;
	LL ret = 1;
	while (n)
	{
		if (n & 1)
			ret = multi_mod(ret, x, mod);
		n >>= 1;
		x = multi_mod(x, x, mod);
	}
	return ret;
}

bool check(LL a, LL n, LL x, LL t)
{   //以a为基，n-1=x*2^t，检验n是不是合数
	LL ret = pow_mod(a, x, n), last = ret;
	for (int i = 1; i <= t; i++)
	{
		ret = multi_mod(ret, ret, n);
		if (ret == 1 && last != 1 && last != n - 1)
			return 1;
		last = ret;
	}
	if (ret != 1)
		return 1;
	return 0;
}

bool Miller_Rabin(LL n)
{
	LL x = n - 1, t = 0;
	while ((x & 1) == 0)
		x >>= 1, t++;
	bool flag = 1;
	if (t >= 1 && (x & 1) == 1)
	{
		for (int k = 0; k < S; k++)
		{
			LL a = rand() % (n - 1) + 1;
			if (check(a, n, x, t))
			{
				flag = 1;
				break;
			}
			flag = 0;
		}
	}
	if (!flag || n == 2)
		return 0;
	return 1;
}

LL gcd(LL a, LL b)
{
	if (a == 0)
		return 1;
	if (a < 0)
		return gcd(-a, b);
	while (b)
	{
		LL t = a % b;
		a = b;
		b = t;
	}
	return a;
}

LL Pollard_rho(LL x, LL c)
{
	LL i = 1, x0 = rand() % x, y = x0, k = 2;
	while (1)
	{
		i++;
		x0 = (multi_mod(x0, x0, x) + c) % x;
		LL d = gcd(y - x0, x);
		if (d != 1 && d != x)
		{
			return d;
		}
		if (y == x0)
			return x;
		if (i == k)
		{
			y = x0;
			k += k;
		}
	}
}

void findfac(LL n)
{           //递归进行质因数分解N
	if (!Miller_Rabin(n))
	{
		factor[tot++] = n;
		return;
	}
	LL p = n;
	while (p >= n)
		p = Pollard_rho(p, rand() % (n - 1) + 1);
	findfac(p);
	findfac(n / p);
}

./number theory/gcd_extend.cpp
void gcd_extend(long long a,long long b,long long &g,long long &x,long long &y)
{
	if (!b)
	{
		g = a;
		x = 1;
		y = 0;
		return;
	}
	gcd_extend(b, a % b, g, y, x);
	y -= a / b * x;
}
./number theory/Miller_Rabin.cpp
typedef long long LL;
#define maxn 10000
const int S = 20;

LL factor[maxn];
int tot;

LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

LL pow_mod(LL x, LL n, LL mod)
{  //返回x^n mod c ,非递归版
	x %= mod;
	if (n == 1)
		return x;
	LL ret = 1;
	while (n)
	{
		if (n & 1)
			ret = multi_mod(ret, x, mod);
		n >>= 1;
		x = multi_mod(x, x, mod);
	}
	return ret;
}

bool check(LL a, LL n, LL x, LL t)
{   //以a为基，n-1=x*2^t，检验n是不是合数
	LL ret = pow_mod(a, x, n), last = ret;
	for (int i = 1; i <= t; i++)
	{
		ret = multi_mod(ret, ret, n);
		if (ret == 1 && last != 1 && last != n - 1)
			return 1;
		last = ret;
	}
	if (ret != 1)
		return 1;
	return 0;
}

bool Miller_Rabin(LL n)
{
	LL x = n - 1, t = 0;
	while ((x & 1) == 0)
		x >>= 1, t++;
	bool flag = 1;
	if (t >= 1 && (x & 1) == 1)
	{
		for (int k = 0; k < S; k++)
		{
			LL a = rand() % (n - 1) + 1;
			if (check(a, n, x, t))
			{
				flag = 1;
				break;
			}
			flag = 0;
		}
	}
	if (!flag || n == 2)
		return 0;
	return 1;
}

./number theory/pow_mod.cpp
LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

LL pow_mod(LL x, LL n, LL mod)
{  //返回x^n mod c ,非递归版
	x %= mod;
	if (n == 1)
		return x;
	LL ret = 1;
	while (n)
	{
		if (n & 1)
			ret = multi_mod(ret, x, mod);
		n >>= 1;
		x = multi_mod(x, x, mod);
	}
	return ret;
}

./number theory/multi_mod.cpp
LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

./.git
./.git/config
./.git/logs
./.git/logs/refs
./.git/logs/refs/heads
./.git/logs/refs/heads/master
./.git/logs/refs/remotes
./.git/logs/refs/remotes/origin
./.git/logs/refs/remotes/origin/master
./.git/logs/refs/remotes/origin/HEAD
./.git/logs/HEAD
./.git/refs
./.git/refs/heads
./.git/refs/heads/master
./.git/refs/remotes
./.git/refs/remotes/origin
./.git/refs/remotes/origin/master
./.git/refs/remotes/origin/HEAD
./.git/refs/tags
./.git/branches
./.git/hooks
./.git/hooks/pre-push.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/update.sample
./.git/hooks/pre-applypatch.sample
./.git/hooks/commit-msg.sample
./.git/hooks/prepare-commit-msg.sample
./.git/hooks/applypatch-msg.sample
./.git/hooks/pre-commit.sample
./.git/hooks/post-update.sample
./.git/objects
./.git/objects/67
./.git/objects/67/a667479361f2540ca2d26e33b37480902d5ba9
./.git/objects/67/3db00036eb8748da1f7cf746b47cb43b24eab9
./.git/objects/fc
./.git/objects/fc/73c88122a9e78193e0a614374ad029287eeef3
./.git/objects/ae
./.git/objects/ae/9fc73d66cc4ec19477128a0e97c2e286957d50
./.git/objects/89
./.git/objects/89/9627785c36abd18b4f20c98cea7999983dae1a
./.git/objects/89/a80e7746136d0e6cb18fe6cd574c861bb47312
./.git/objects/89/bb167c71dee9f98bcec5e08daa8e58fd8b639c
./.git/objects/d6
./.git/objects/d6/8e2792465893f452794dc5b41159d2763e6a10
./.git/objects/18
./.git/objects/18/f2de6376be8422e46c3ba37ed26f8ee5926c57
./.git/objects/18/024269d2e3ffb1cf412afa4bf98f7c60ed3a84
./.git/objects/18/4aeadebbf58b825c13126c29f377b4d3e0e32a
./.git/objects/e9
./.git/objects/e9/52615d1840f04f79d82e0074330612791ec7c5
./.git/objects/d7
./.git/objects/d7/2b6a4dd82998b6b81cc1aa5a585b690c2ac2b4
./.git/objects/c1
./.git/objects/c1/f6acbe2fb9c374cec766346bd223fd917ae5fc
./.git/objects/c1/1e1dec91e68bebb93530adca752723c9228933
./.git/objects/06
./.git/objects/06/afd98896cf4dd04e479f76d6c5afccf6dd944e
./.git/objects/71
./.git/objects/71/ab148ed58f3b5e0829ebe1b1e1f68a1f4a83aa
./.git/objects/71/223b867f2f9a9672bca3c6d14f829e350596dd
./.git/objects/02
./.git/objects/02/1706007fcee372ea3321a05479eadcda7e67ed
./.git/objects/03
./.git/objects/03/c0bfd7f6e8f359d3573169c9b2151866ca480d
./.git/objects/81
./.git/objects/81/c0bc850b6a38da2a1a2f68f2ee60f5de6218a2
./.git/objects/81/18d6c06defafbc11b97bd5fa3465d9606ac6fb
./.git/objects/81/3e4b89f00f37540c066a665ea08e117897520b
./.git/objects/46
./.git/objects/46/7634a79cf1f7b818335b70a2cb625c3f4a924e
./.git/objects/46/b1d678267437b48d273e6e5f43a0051703140d
./.git/objects/b8
./.git/objects/b8/2326b82b9599e4fb6940359b680d2eebc4bdfd
./.git/objects/a8
./.git/objects/a8/c4612649d5fd9c121a8e7d390f7a087cdfba47
./.git/objects/1d
./.git/objects/1d/db8e6c43e67c1845c8638a59aac3a17e2a57da
./.git/objects/1d/73986659aa7da4b27cabf1b3f3ff58b0ab9cef
./.git/objects/1d/cdbcd8c2e8bd1d24fd4568b2bc379b04294a84
./.git/objects/8a
./.git/objects/8a/4fb35d4ac4f4d5ba36448b3189296d016597af
./.git/objects/1a
./.git/objects/1a/92b418a3ce6b11ec0a3c28cd5d7596d605c52a
./.git/objects/70
./.git/objects/70/b64845b98031716fabeb4045e4435b0679d726
./.git/objects/12
./.git/objects/12/fb39952e968b0c82162271683e6f8498e97d9d
./.git/objects/60
./.git/objects/60/b7a87f26e93fe4506498c17a8529b32b240827
./.git/objects/ce
./.git/objects/ce/fd3098612810e02b0cab10905aea9fa7349009
./.git/objects/c7
./.git/objects/c7/fdab791c50fad29b284caffce4b5d556894717
./.git/objects/e6
./.git/objects/e6/e128bbf5b6bae3267d9b40723ee8ffa8b516c5
./.git/objects/2f
./.git/objects/2f/7ee88e7b57f759d5f5fcdb2ab7b93ca1cbd44b
./.git/objects/be
./.git/objects/be/0eab963415570e60d7586daaaecf757d9d6695
./.git/objects/9f
./.git/objects/9f/c793fffd8e5f0a53027ed64f19a0667a277fae
./.git/objects/9f/5893a9e760e818ce7be87cb34338a21d043aed
./.git/objects/9f/67fca41a8a214317b543a1326ad7a5bba7712d
./.git/objects/9f/053bfdfb352a67d42345457e609714b7bca220
./.git/objects/pack
./.git/objects/ed
./.git/objects/ed/6326c14fde6fe90e4832810eb195ebb3d4c6ce
./.git/objects/21
./.git/objects/21/73f0600dd54805dc310c17bae5aa18ddd1a99e
./.git/objects/34
./.git/objects/34/7e29ed66186e302e75ddc5ca63f68d14909b25
./.git/objects/34/c22fce1f5f73d7568cc6667536b3949593d4e6
./.git/objects/d4
./.git/objects/d4/961c038c84078f559ed56e4bad7f040a3854bd
./.git/objects/a7
./.git/objects/a7/bc68746b27c65af437354189882c91f513f38d
./.git/objects/3a
./.git/objects/3a/9d175372ae85c5cdd524c2dc2e303fef87c180
./.git/objects/72
./.git/objects/72/4442e8a06d9c74303eae6a2cb0515f17cd3348
./.git/objects/72/44e8a6acbb445e59de653e6c8afa03b4cdbd55
./.git/objects/9e
./.git/objects/9e/f1430d4aea25ea6f52889614639d03cdb95406
./.git/objects/d8
./.git/objects/d8/f5e555739839c38b6a064218e68d47f2f28a57
./.git/objects/63
./.git/objects/63/b785ec23df7687636151e21cb7bda38de021f2
./.git/objects/64
./.git/objects/64/5fd5145748d47815a5e2250c0b173b876bece6
./.git/objects/64/f1034fd048ddeef69ea23e2c927d17fe8063ee
./.git/objects/64/6305eea54e99634ec1bdd90f53e69b8c78a23e
./.git/objects/64/fa380633dbfe84e0a2c05e29dbf76f33cb0138
./.git/objects/8c
./.git/objects/8c/5c6cbf9b66b8a96f3e81949d4eead48363074b
./.git/objects/5b
./.git/objects/5b/0958afa4de86bebca1e76721c70d4090674cbb
./.git/objects/5b/47bc458ca6a7723059b023387a93b62bb760c1
./.git/objects/bc
./.git/objects/bc/7f9fc88f1f3f01a99c197c4c844e1dd70eaed0
./.git/objects/11
./.git/objects/11/39c964654182f6bacc555d93db9cad52f5ee10
./.git/objects/11/be73bb7e8eb8f1dc99b1750a8d0d422164df33
./.git/objects/ac
./.git/objects/ac/2f584e8722f1f673e3866ae5825fec20f82afd
./.git/objects/4e
./.git/objects/4e/4903d5681196a10f79c6a7353b93eecf1ede05
./.git/objects/4e/cf123ef4e406aaa88fde9b2188364fa71a0b92
./.git/objects/53
./.git/objects/53/3effd32e38770a5b44093547c9346e13ecd411
./.git/objects/b2
./.git/objects/b2/fc3cdbebd76db81d90fe0b0419270e5d157e57
./.git/objects/a2
./.git/objects/a2/af9abeb49194dfb3b40119ff202f11410713c3
./.git/objects/b7
./.git/objects/b7/2172e03591e2962408ff948268d217615de8f1
./.git/objects/d1
./.git/objects/d1/e7fc13695c0f3c5903e5702e6cf26e402bd382
./.git/objects/f1
./.git/objects/f1/494d5cd62f53f49c184d495823ccfcd1d98ecc
./.git/objects/bf
./.git/objects/bf/2221f28f689311074ae44b8fa3eec848557612
./.git/objects/1c
./.git/objects/1c/ddf5e5545d3283eb3227325c220b9da350fd8b
./.git/objects/1c/3b7ed9274177b56c6e3d43a22f9da9995f6ce6
./.git/objects/a3
./.git/objects/a3/82489f8c978c6d7312d4a4e59dfe3dd8e987ee
./.git/objects/ef
./.git/objects/ef/5e6ad0b314bee762a8866e0458dd9462e4bb63
./.git/objects/ef/b8e0e72b9be3bf56c505f7fa24bbd7cb198bd3
./.git/objects/93
./.git/objects/93/4507fd2dc56e25d65b16ebef4093dc5579d5b3
./.git/objects/24
./.git/objects/24/49248f88e9498168555d20b7799f40fb0fb6e2
./.git/objects/b0
./.git/objects/b0/4dffca3c529cce2a6b076d396a9504a49b9393
./.git/objects/7d
./.git/objects/7d/7d86632a623fa6e4619cad5b9265f395686e68
./.git/objects/51
./.git/objects/51/a4b7dde402742be8d5328d8b8d89dd276c8ed3
./.git/objects/51/0493141b9d0a126e667259ccd7620b699d87e3
./.git/objects/2b
./.git/objects/2b/1c297dcc60401d24b5a3b209ea65070a66e1dc
./.git/objects/e4
./.git/objects/e4/5c0a9d3bce2ee819ecc70bde0cdc42163a0803
./.git/objects/fb
./.git/objects/fb/4fbe707905c2a82028aaaa58b3f2b68600bc8a
./.git/objects/0c
./.git/objects/0c/ed11119138a9c451e03f774bc493add2772830
./.git/objects/6b
./.git/objects/6b/41f91a052e02905c0cf8fc77573fdee76537af
./.git/objects/6b/efadf45fa8775637189568bc4dda841f6885a6
./.git/objects/e5
./.git/objects/e5/33a1df59809d49ccaabc2dddc787af7a35d11c
./.git/objects/13
./.git/objects/13/45339cf6219d187eb04d08539855eac21b3e36
./.git/objects/8e
./.git/objects/8e/7e0aa5f008edf224ea6104253bbcbbc73da9fe
./.git/objects/8e/8c3e757d0f841262f08ca0af983a02bb0a3f23
./.git/objects/8e/bf5cd83ca5983f3941a88eb996a5aa279c69df
./.git/objects/54
./.git/objects/54/1df5ac5045eb8605fdec76c34d5d674c5a0c14
./.git/objects/5c
./.git/objects/5c/f10300d3bb23be5898d9796e0497288002e428
./.git/objects/ba
./.git/objects/ba/be72da2c78162a38c989b548b2e936d8ca7a0b
./.git/objects/23
./.git/objects/23/98cb91c13ee62bf19009401cfa176f57f8afad
./.git/objects/9d
./.git/objects/9d/ea03c86a0143ad2d166f66b438b4c365451dcf
./.git/objects/a6
./.git/objects/a6/08de808d2337b90383ee5036cb7fa959c2352f
./.git/objects/a6/3c73ee351b8baba5a8e283bd6fb512fa526cc7
./.git/objects/de
./.git/objects/de/8d8c3767be690cfa52eb80fdd1b3af63f4b618
./.git/objects/b9
./.git/objects/b9/2178603d06a1118ab4217dc78eebd94bd1a03a
./.git/objects/b9/f886e52ca11361f0676a86b7708e30eb64705a
./.git/objects/5d
./.git/objects/5d/a9c45f1bdf935bb74fcd7d6d6eb9e72dd0324d
./.git/objects/5d/9ea5784ad9f6edda3a7f1056eb21b4a5352f67
./.git/objects/47
./.git/objects/47/684633fbcd16b3d9dd676a22847fa00ce8b7e2
./.git/objects/bb
./.git/objects/bb/d83eb3852f54392b3ede7f88f67acf2a7999da
./.git/objects/bb/e811746b60c16d38aab53e35625a10d78d6c99
./.git/objects/cd
./.git/objects/cd/76cac505234691d8e8f761e21529939c5c6d3a
./.git/objects/35
./.git/objects/35/4ae4fa59c286f6d8f6b585740ed694db81c528
./.git/objects/04
./.git/objects/04/71bd16b3924d40fc7e3eaec46f407f55b06a40
./.git/objects/73
./.git/objects/73/f8759ccedc64939fd655a4e49293ca36104d01
./.git/objects/73/73dd124788276afa62368e41ef7c29d90a1c71
./.git/objects/97
./.git/objects/97/371f19b7996152b5c7edb9bd416a7150a79812
./.git/objects/01
./.git/objects/01/62c31666db92b15d87cd164b5c33d657a6deeb
./.git/objects/c2
./.git/objects/c2/7a220d2c032fc336c4aabec469455130e7acff
./.git/objects/c2/63b47ce0809365d484c03dc8cb5dfa5b4c7f3c
./.git/objects/84
./.git/objects/84/466eacfaf3a99f750c608ed253998125de3769
./.git/objects/40
./.git/objects/40/4b9565c9280997fa3c5b0e50b39a7e63e6ab9e
./.git/objects/7c
./.git/objects/7c/859adc15db2998c44e03addcd076f20bd571cf
./.git/objects/7c/84334d1366664435db522bcd4604788241c29d
./.git/objects/15
./.git/objects/15/827ad1a295524eefa2499c1c5caa43541debbc
./.git/objects/42
./.git/objects/42/554fe774d85f20af4c89a235a0d4756ed54292
./.git/objects/32
./.git/objects/32/dd375051559570e0c9c648e08d907605bd1f49
./.git/objects/32/63372ea2b49d4e0e746079d1f197e08d4f6f09
./.git/objects/19
./.git/objects/19/32209f11d810adced9fd961c44b4c441fba320
./.git/objects/19/9bedf7334e854024cd8757f3b5a63633e9c852
./.git/objects/83
./.git/objects/83/b5864ace648750961ddb0e014bc9aaf0798643
./.git/objects/9c
./.git/objects/9c/b961fde62b5e73aa4a988dd6ceb11e83213701
./.git/objects/3c
./.git/objects/3c/6d6cbc84db639c2b60ae2d15ab882ca96ced8d
./.git/objects/08
./.git/objects/08/8fcfd3c3b008e581222351388a9f7bf794a6e8
./.git/objects/29
./.git/objects/29/a13f85552e8dd74aed15e41c423e9ed3e4e267
./.git/objects/36
./.git/objects/36/448000cbb643000e0809f2745d599ba6487945
./.git/objects/f9
./.git/objects/f9/7d598f9cd8467ba3a8a37dea75ee9656902f58
./.git/objects/98
./.git/objects/98/0774141e45b8e46273815e4e25ffe98f5aaef4
./.git/objects/98/52e75796809d2621c03c6aa9ede968a0f5f6da
./.git/objects/eb
./.git/objects/eb/5e015a3f77168483c0cce88915b8fb629d6c70
./.git/objects/f4
./.git/objects/f4/263370adc238fb823b9bd64357413c10789a5c
./.git/objects/f4/9095ab2a0bafd4216d621870c0ff02f5223b5e
./.git/objects/2e
./.git/objects/2e/2f433276e8ff522d7540961816095fd607762a
./.git/objects/b6
./.git/objects/b6/86c09f1614e0ca67ce9fd382698caaa56da7ea
./.git/objects/info
./.git/objects/e7
./.git/objects/e7/a3c28651b89cd56136242f5c2035833cd21e91
./.git/objects/f3
./.git/objects/f3/dbccd79ea387c065e26cd4ae691c8a5a16c268
./.git/objects/dc
./.git/objects/dc/8963dbf74af729ec5d0f887677c657ce171b3a
./.git/objects/dc/67c39aaf8d3dc5e245ba3ff62511f2a8221d72
./.git/objects/cc
./.git/objects/cc/1347af1ac520fe5231f565319fee5c799f584f
./.git/objects/cc/59593ecd3a108619e085ab34d474f6607940b0
./.git/objects/41
./.git/objects/41/dcb6b486d0774db91470321f8b67894e1866e4
./.git/objects/c3
./.git/objects/c3/af618dae238c3ca70041eada94d118b7303682
./.git/objects/fd
./.git/objects/fd/b7898e4d20773bba934c7a4e32093f8ae4ac11
./.git/objects/4d
./.git/objects/4d/7d06727d6a093249521e474ffc7fa6b0c193b7
./.git/objects/4d/d01212cbddfa764dda87ea5e6efb641a366d74
./.git/objects/4d/63c437602767660b88f40e870d0af9cc813d0b
./.git/objects/ad
./.git/objects/ad/8fbfe863d6a180c688fd4484545b6692a6e6bd
./.git/objects/ad/a4a77618eb6e48eece71c38e6a1ba8c2657acc
./.git/objects/7e
./.git/objects/7e/ee5abbd6a2ff91fd964756d01e27b6893f85a3
./.git/objects/79
./.git/objects/79/03b70d7e9c6ca6865b92fb6bcd33a8968c8de0
./.git/objects/62
./.git/objects/62/21dd3c64a4166a682fe25dcbb0ddd8f4d31cc0
./.git/objects/62/082a538ee1ea4c71ce7c2997ca1445722f8f38
./.git/objects/5f
./.git/objects/5f/7100ccfd906fafa06a6fb5e30a1473567aa388
./.git/objects/95
./.git/objects/95/d42d0245169eba072030eb2602ec5245938b07
./.git/objects/df
./.git/objects/df/aae53f2bbfe276c6f63bfbe7c2d58a00d85989
./.git/objects/b5
./.git/objects/b5/2e2ac619d87926be2719e9c6d48db889d9f24a
./.git/objects/27
./.git/objects/27/0d224c9711130cf70a42e7dd2c9eb58c977238
./.git/objects/27/6d012d8689677af5c8acf3a0d51dee25dbcd77
./.git/objects/87
./.git/objects/87/d69dbd66ec0a73a3d7f77cd7ba1f73f8b6329f
./.git/objects/56
./.git/objects/56/df7dd5916b78ea60b37834a3f746cc5dbc46a7
./.git/objects/b1
./.git/objects/b1/9633112cbfd8e77b68a584d7cd15b93ee15f8a
./.git/objects/b1/fb367d9a71d5af2df000110c28ca351b5fbb05
./.git/objects/28
./.git/objects/28/a846e40a6cfc45758cf9b573b9b57b66c7fc22
./.git/objects/8f
./.git/objects/8f/8e7510308d06c18eb9fee58000f4549b769277
./.git/objects/1b
./.git/objects/1b/f5748f022140ea35f9814f3c37d500b5dc0a4f
./.git/COMMIT_EDITMSG
./.git/packed-refs
./.git/description
./.git/HEAD
./.git/index
./.git/info
./.git/info/exclude
./network flow
./network flow/rng_58_dinic.cpp
#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef int F;
#define F_INF (1<<29)
#define MAXV 1000
#define MAXE 1000 // E*2!

F cap[MAXE],flow[MAXE];
int to[MAXE],_prev[MAXE],last[MAXV],used[MAXV],level[MAXV];

struct MaxFlow{
    int V,E;

    MaxFlow(int n){
        int i;
        V = n; E = 0;
        REP(i,V) last[i] = -1;
    }

    void add_edge(int x, int y, F f){
        cap[E] = f; flow[E] = 0; to[E] = y; _prev[E] = last[x]; last[x] = E; E++;
        cap[E] = 0; flow[E] = 0; to[E] = x; _prev[E] = last[y]; last[y] = E; E++;
    }

    bool bfs(int s, int t){
        int i;
        REP(i,V) level[i] = -1;
        queue <int> q;
        q.push(s); level[s] = 0;
        while(!q.empty()){
            int x = q.front(); q.pop();
            for(i=last[x];i>=0;i=_prev[i]) if(level[to[i]] == -1 && cap[i] > flow[i]) {q.push(to[i]); level[to[i]] = level[x] + 1;}
        }
        return (level[t] != -1);
    }

    F dfs(int v, int t, F f){
        int i;
        if(v == t) return f;
        for(i=used[v];i>=0;used[v]=i=_prev[i]) if(level[to[i]] > level[v] && cap[i] > flow[i]){
            F tmp = dfs(to[i],t,min(f,cap[i]-flow[i]));
            if(tmp > 0) {flow[i] += tmp; flow[i^1] -= tmp; return tmp;}
        }
        return 0;
    }

    F maxflow(int s, int t){
        int i;
        while(bfs(s,t)){
            REP(i,V) used[i] = last[i];
            while(dfs(s,t,F_INF) != 0);
        }
        F ans = 0;
        for(i=last[s];i>=0;i=_prev[i]) ans += flow[i];
        return ans;
    }

};
./network flow/min_cost_flow.cpp

#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define N MAX_NODE_NUM
#define E MAX_EDGE_NUM * 2
#define INF 0x3f3f3f3f

struct Edge
{
	int next, v, c, w;
	Edge()
	{}
	Edge(int next, int v, int c, int w): next(next), v(v), c(c), w(w)
	{}
}edge[E];

int node_num, edge_cnt;
bool vis[N];
int head[N], pre[N], pre_edge[N];
int dist[N];
int src, sink;
int q[MAX_NODE_NUM];
int front, rear, q_size;

void q_init(int size)
{
	front = 0;
	rear = 0;
	q_size = size;
}

void q_push(int a)
{
	q[rear++] = a;
	rear %= q_size;
}

int q_pop()
{
	int ret = q[front++];
	front %= q_size;
	return ret;
}

bool q_empty()
{
	return front == rear;
}


void add_edge(int u, int v, int c, int w)
{
	edge[edge_cnt] = Edge(head[u], v, c, w);
	head[u] = edge_cnt++;
}

void add_edges(int u, int v, int c, int w)
{
	add_edge(u, v, c, w);
	add_edge(v, u, 0, -w);
}

void SPFA()
{
	memset(vis, 0, sizeof(vis));
	fill(dist, dist + node_num, INF);
	dist[src] = 0;
	pre[src] = src;
	vis[src] = true;
	q_init(node_num);
	q_push(src);
	while (!q_empty())
	{
		int u = q_pop();
		vis[u] = false;
		for (int i = head[u]; ~i; i = edge[i].next)
		{
			int v = edge[i].v;
			if (!edge[i].c || edge[i].w + dist[u] >= dist[v])
				continue;
			dist[v] = edge[i].w + dist[u];
			if (!vis[v])
			{
				vis[v] = true;
				q_push(v);
			}
			pre[v] = u;
			pre_edge[v] = i;
		}
	}
}

int mincost(int src, int sink)
{
	int flow = 0;
	int cost = 0;
	while (true)
	{
		memset(pre, -1, sizeof(pre));
		SPFA();
		if (-1 == pre[sink])
			break;
		int max_flow = INF;
		for (int i = sink; i != src; i = pre[i])
			if (edge[pre_edge[i]].c < max_flow)
				max_flow = edge[pre_edge[i]].c;
		flow += max_flow;
		cost += dist[sink] * max_flow;
		for (int i = sink; i != src; i = pre[i])
		{
			edge[pre_edge[i]].c -= max_flow;
			edge[pre_edge[i] ^ 1].c += max_flow;
		}
	}
	return cost;
}

void init()
{
	edge_cnt = 0;
	memset(head, -1, sizeof(head));
}
./network flow/hugary_dfs_matrix.cpp
#define MAX_X 0
#define MAX_Y MAX_X

int matrix[MAX_X][MAX_Y];
bool vis[MAX_X];
int match[MAX_X];
int x_num, y_num;

bool find_match(int a)
{
	for (int i = 0; i < y_num; i++)
		if (matrix[a][i] &&!vis[i])
		{
			vis[i] = true;
			if (match[i] == -1|| find_match(match[i]))
			{
				match[i] = a;
				return true;
			}
		}
	return false;
}

int max_match()
{
	memset(match, -1, sizeof(match));
	for (int i = 0; i < x_num; i++)
	{
		memset(vis, 0, sizeof(vis));
		find_match(i);
	}
	int ans = 0;
	for (int i = 0; i < x_num; i++)
		if (match[i] != -1)
			ans++;
	return ans;
}

void init_match(int x, int y)
{
	x_num = x;
	y_num = y;
}
./network flow/dinic.cpp
#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define INF 0x3f3f3f3f

struct Edge
{
	int next, v, f;
	Edge()
	{}
	Edge(int next, int v, int f):next(next), v(v), f(f)
	{}
} edge[MAX_EDGE_NUM * 2];

int head[MAX_NODE_NUM];
int q[MAX_NODE_NUM];
bool vis[MAX_NODE_NUM];
int cur[MAX_NODE_NUM];
int dep[MAX_NODE_NUM];
int edge_cnt;
int path[MAX_NODE_NUM];
int front, rear, q_size;

void add_edge(int u, int v, int f)
{
	edge[edge_cnt] = Edge(head[u], v, f);
	head[u] = edge_cnt++;
	edge[edge_cnt] = Edge(head[v], u, 0);
	head[v] = edge_cnt++;
}

void init()
{
	edge_cnt = 0;
	memset(head, -1, sizeof(head));
}

void q_init(int size)
{
	front = 0;
	rear = 0;
	q_size = size;
}

void q_push(int a)
{
	q[rear++] = a;
	rear %= q_size;
}

int q_pop()
{
	int ret = q[front++];
	front %= q_size;
	return ret;
}

void bfs(int s, int t)
{
	memset(vis, 0, sizeof(vis));
	memset(dep, -1, sizeof(dep));
	q_init(MAX_NODE_NUM);
	q_push(s);
	vis[s] = true;
	dep[s] = 0;
	while (front != rear && !vis[t])
	{
		int u = q_pop();
		for (int i = head[u]; ~i; i = edge[i].next)
		{
			int v = edge[i].v;
			if (!vis[v] && edge[i].f > 0)
			{
				q_push(v);
				vis[v] = true;
				dep[v] = dep[u] + 1;
			}
		}
	}
}

int add_flow(int path[], int &path_n)
{
	int min_edge = -1, delta = INF;
	for (int i = 0; i < path_n; ++i)
	{
		if (edge[path[i]].f < delta)
		{
			delta = edge[path[i]].f;
			min_edge = i;
		}
	}
	for (int i = 0; i < path_n; ++i)
	{
		edge[path[i]].f -= delta;
		edge[path[i] ^ 1].f += delta;
	}
	path_n = min_edge;
	return delta;
}

int last_node(int path[], int path_n, int s)
{
	if (path_n)
		return edge[path[path_n - 1]].v;
	return s;
}

int find_next(int start)
{
	for (int e = cur[start]; ~e; e = edge[e].next)
		if (edge[e].f && dep[start] + 1 == dep[edge[e].v])
			return e;
	return -1;
}

int dfs(int s, int t)
{
	int ret = 0;
	int path_n = 0;
	int x = s;
	memcpy(cur, head, sizeof(cur));
	while (true)
	{
		if (x == t)
		{
			ret += add_flow(path, path_n);
			x = last_node(path, path_n, s);
		}
		int next_edge = find_next(x);
		cur[x] = next_edge;
		if (next_edge == -1)
		{
			if (path_n == 0)
				break;
			dep[x] = -1;
			--path_n;
			x = last_node(path, path_n, s);
			continue;
		}
		path[path_n++] = next_edge;
		x = edge[next_edge].v;
	}
	return ret;
}

int dinic(int s, int t)
{
	int ret = 0;
	while (true)
	{
		bfs(s, t);
		if (dep[t] == -1)
			return ret;
		ret += dfs(s, t);
	}
	return -1;
}


./network flow/hugary_dfs_list.cpp
#define MAX_X 0
#define MAX_Y MAX_X
#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM MAX_X

struct Edge
{
	int v, next;
	Edge()
	{}
	Edge(int v, int next):v(v), next(next)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
bool vis[MAX_X];
int match[MAX_X];
int x_num, y_num;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v)
{
	edge[edge_cnt].v = Edge(v, head[u]);
	head[u] = edge_cnt++;
}

bool find_match(int a)
{
	for (int i = head[a]; ~i; i = edge[i].next)
	{
		int v = edge[i].v;
		if (vis[v])
			continue;
		vis[v] = true;
		if (match[v] == -1 || find_match(match[v]))
		{
			match[v] = a;
			return true;
		}
	}
	return false;
}

int max_match()
{
	memset(match, -1, sizeof(match));
	for (int i = 0; i < x_num; i++)
	{
		memset(vis, 0, sizeof(vis));
		find_match(i);
	}
	int ans = 0;
	for (int i = 0; i < x_num; i++)
		if (match[i] != -1)
			ans++;
	return ans;
}

void init_match(int x, int y)
{
	x_num = x;
	y_num = y;
}

./dynamic programming
./dynamic programming/digits_leading_zeros.cpp
const int MAX_DIGIT = 20;

long long n;
int f[MAX_DIGIT];
long long memoize[MAX_DIGIT][...];

int to_digits(long long a)
{
	int ret = 0;
	while (a > 0)
	{
		f[ret++] = a % 10;
		a /= 10;
	}
	return ret;
}

long long dfs(int digit, bool less, bool leading_zero, ...)
{
	if (digit < 0)
	{
		return ...;
	}
	if (less && !leading_zero && memoize[digit][...] != -1)
	{
		return memoize[digit][...];
	}
	int limit = less ? 9 : f[digit];
	long long ret = 0;
	for (int i = 0; i <= limit; i++)
	{
		ret += dfs(digit - 1, less || i < f[digit], leading_zero && i == 0, ...);
	}
	if (less && !leading_zero)
	{
		memoize[digit][...] = ret;
	}
	return ret;
}

long long work(long long n)
{
	if (n < 0)
	{
		return 0;
	}
	if (n == 0)
	{
		//return 1;
	}
	int len = to_digits(n);
	memset(memoize, -1, sizeof(memoize));
	return dfs(len - 1, false, 0, ...);
}
./dynamic programming/digits.cpp
const int MAX_DIGIT = 20;

long long n;
int f[MAX_DIGIT];
long long memoize[MAX_DIGIT][...];

int to_digits(long long a)
{
	int ret = 0;
	while (a > 0)
	{
		f[ret++] = a % 10;
		a /= 10;
	}
	return ret;
}

long long dfs(int digit, bool less, ...)
{
	if (digit < 0)
	{
		return ...;
	}
	if (less && memoize[digit][...] != -1)
	{
		return memoize[digit][...];
	}
	int limit = less ? 9 : f[digit];
	long long ret = 0;
	for (int i = 0; i <= limit; i++)
	{
		ret += dfs(digit - 1, less || i < f[digit], ...);
	}
	if (less)
	{
		memoize[digit][...] = ret;
	}
	return ret;
}

long long work(long long n)
{
	if (n < 0)
	{
		return 0;
	}
	if (n == 0)
	{
		//return 1;
	}
	int len = to_digits(n);
	memset(memoize, -1, sizeof(memoize));
	return dfs(len - 1, false, ...);
}
./data structures
./data structures/queue.cpp
template<typename T>
class queue
{
	T data[MAX_Q_LEN];
	int head, tail;

public:
	queue()
	{
		head = tail = 0;
	}

	bool empty()
	{
		return head == tail;
	}

	void pop()
	{
		head++;
		if (head >= MAX_Q_LEN)
			head = 0;
	}

	void push(T a)
	{
		data[tail++] = a;
		if (tail >= MAX_Q_LEN)
			tail = 0;
	}

	T front()
	{
		return data[head];
	}
};

./data structures/tree_dfn.cpp
int dfn[MAX_N], dfn2[MAX_N];
int time_count;

void dfs(int u, int father)
{
	dfn[u] = time_count++;
	for (int i = 0; i < (signed)edge[u].size(); i++)
	{
		int v = edge[u][i];
		if (v != father)
			dfs(v, u);
	}
	dfn2[u] = time_count;	//can be deleted, if dfn2 is not necessary.
}

./data structures/dsu.cpp

struct DSU
{
	int father[MAX_NODE_NUM];

	DSU()
	{}

	DSU(int n)
	{
		for (int i = 0; i < n; i++)
		{
			father[i] = i;
		}
	}

	int find(int a)
	{
		int ret = a;
		while (father[ret] != ret)
			ret = father[ret];
		while (father[a] != a)
		{
			int b = a;
			a = father[a];
			father[b] = ret;
		}
		return ret;
	}

	void merge(int a, int b)
	{
		father[find(a)] = father[find(b)];
	}
};


./data structures/binary_indexed_tree.cpp
int binary_indexed_tree[MAX_N];

int low_bit(int x)
{
	return x & (-x);
}

void add(int pos, int val)
{
	for (int i = pos; i < MAX_N; i += low_bit(i))
	{
		binary_indexed_tree[i] += val;
	}
}

int sum(int pos)
{
	int ret = 0;
	for (int i = pos; i > 0; i -= low_bit(i))
	{
		ret += binary_indexed_tree[i];
	}
	return ret;
}


./data structures/trie.cpp
const int MAX_CHAR_NUM = 0;
const int MAX_NODE_NUM = 0;

int trie[MAX_NODE_NUM][MAX_CHAR_NUM];
int node_num;

void trie_init()
{
	memset(trie, -1, sizeof(trie));
	node_num = 1;
}

int convert(char ch)
{
	return ch - 'a';
}

void add(char* st)
{
	int u = 0;
	for (int i = 0; st[i]; i++)
	{
		int index = convert(st[i]);
		if (trie[u][index] == -1)
		{
			trie[u][index] = node_num++;
		}
		u = trie[u][index];
	}
}
./IO_accelerator
./IO_accelerator/read_int.cpp
inline int read_int()
{
    int num = 0;
    int sign = 1;
    bool skip = false;
    int c = 0;
    while((c = getchar()) != EOF)
    {
        if(c == '-')
        {
            sign = -1;
            skip = true;
        }
        else if(c >= '0' && c <= '9')
        {
            num = num * 10 + c - '0';
            skip = true;
        }
        else if(skip)
	{
		break;
	}
    }
    return num * sign;
}

./segment tree
./segment tree/segment_tree(general).cpp
struct SegmentTree
{

    struct Node
    {
        int l, r;
        Node *pleft, *pright;
        //add the needed variable
    }tree[MAX_INTERVAL *4];

    int node_cnt;

    void init()
    {
        node_cnt = 0;
    }

    Node* new_node()
    {
        node_cnt++;
        return tree + node_cnt;
    }

    void build_tree(Node *proot, int s, int e)
    {
        proot->l = s;
        proot->r = e;
        //init the variables
        if (s == e)
        {
            proot->pleft = proot->pright = NULL;
            return;
        }
        int mid = (s + e) / 2;
        build_tree(proot->pleft = new_node(), s, mid);
        build_tree(proot->pright = new_node(), mid + 1, e);
    }

    void pull_up(Node *proot)
    {
            //do something
    }

    void push_down(Node *proot)
    {
            //do something
    }

    void update(Node *proot, int start, int end, int value)
    {
        if (start > proot->r || end < proot->l)
            return;
        start = max(start, proot->l);
        end = min(end, proot->r);
        if (start == proot->l && end == proot->r)
        {
            //do something
            return;
        }
        push_down(proot);
        update(proot->pleft, start, end, value);
        update(proot->pright, start, end, value);
        pull_up(proot);
    }

    int query(Node *proot, int start, int end)
    {
        int ret = proot->value;
        if (start > proot->r || end < proot->l)
            return 0;
        start = max(start, proot->l);
        end = min(end, proot->r);
        if (start == proot->l && end == proot->r)
        {
            //do something
        }
        push_down(proot);
        ret = max(ret, query(proot->pleft, start, end));
        ret = max(ret, query(proot->pright, start, end));
        pull_up(proot);
        return ret;
    }
};
./segment tree/segment_tree(cover).cpp

struct SegmentTree
{

	struct Node
	{
		int l, r;
		long long h;
		Node *pleft, *pright;
		long long value;
	}tree[MAX_INTERVAL *4];

	int discrete[MAX_INTERVAL *2], node_cnt, discrete_num;

	void init()
	{
		node_cnt = 0;
	}

	void build_tree(Node *proot, int s, int e)
	{
		proot->l = s;
		proot->r = e;
		proot->h = 0;
		proot->value = 0;
		if (s == e)
		{
			proot->pleft = proot->pright = NULL;
			return;
		}
		node_cnt++;
		proot->pleft = tree + node_cnt;
		node_cnt++;
		proot->pright = tree + node_cnt;
		int mid = (s + e) / 2;
		build_tree(proot->pleft, s, mid);
		build_tree(proot->pright, mid + 1, e);
	}

	void pull_up(Node *proot)
	{
		proot->value = proot->pleft->value + proot->pright->value;
	}

	void push_down(Node *proot)
	{
		if (proot->h != -1 && proot->r != proot->l)
		{
			update(proot->pleft, proot->pleft->l, proot->pleft->r, proot->h);
			update(proot->pright, proot->pright->l, proot->pright->r, proot->h);
			proot->h = -1;
		}
	}

	void update(Node *proot, int start, int end, long long h)
	{
		if (start > proot->r || end < proot->l)
			return;
		start = max(start, proot->l);
		end = min(end, proot->r);
		if (start == proot->l && end == proot->r)
		{
			proot->h = h;
			proot->value = h * (discrete[proot->r + 1] - discrete[proot->l]);
			return;
		}
		push_down(proot);
		update(proot->pleft, start, end, h);
		update(proot->pright, start, end, h);
		pull_up(proot);
	}
};


./segment tree/segment_tree(discrete).cpp
#define MAX_LEN 0

struct Node
{
	Node *pleft;
	Node *pright;
	long long l, r;
	long long sum;
} tree[MAX_LEN * 3];

int len;
long long sum;
int ncount;

void build_tree(Node *proot, int l, int r)
{
	int mid = (l + r) / 2;
	proot->l = l;
	proot->r = r;
	proot->sum = 0;
	if (l == r)
		return;
	ncount++;
	proot->pleft = tree + ncount;
	ncount++;
	proot->pright = tree + ncount;
	build_tree(proot->pleft, l, mid);
	build_tree(proot->pright, mid + 1, r);
}

long long query(Node *proot, long long l, long long r)
{
	if (l > proot->r || r < proot->l)
	{
		return 0;
	}
	l = max(proot->l, l);
	r = min(proot->r, r);
	if (l == proot->l && r == proot->r)
	{
		D(puts("***"));
		return proot->sum;
	}
	return (query(proot->pleft, l, r) + query(proot->pright, l, r)) % MOD;
}

void update(Node *proot, long long pos, long long a)
{
	if (pos > proot->r || pos < proot->l)
	{
		return;
	}
	proot->sum += a;
	proot->sum %= MOD;
	if (proot->l == proot->r)
	{
		return;
	}
	update(proot->pleft, pos, a);
	update(proot->pright, pos, a);
}

./segment tree/segment_tree(reserve).cpp
#define MAX_INTERVAL 100001

struct Node
{
	int        l, r;
	long long nsum, inc;
	Node    *pleft, *pright;
};

int	node_cnt;
Node    tree[MAX_INTERVAL * 3];

void buildtree(Node *proot, int s, int e)
{
	proot->l = s;
	proot->r = e;
	proot->inc = 0;
	proot->nsum = 0;
	if (s == e)
	{
		proot->pleft = proot->pright = NULL;
		return;
	}
	node_cnt++;
	proot->pleft = tree + node_cnt;
	node_cnt++;
	proot->pright = tree + node_cnt;
	buildtree(proot->pleft, s, (s + e) / 2);
	buildtree(proot->pright, (s + e) / 2 + 1, e);
}

void insert(Node *proot, int s, int e, long long increase)
{
	if (s > proot->r || e < proot->l)
		return;
	s = max(s, proot->l);
	e = min(e, proot->r);
	if (s == proot->l && e == proot->r)
	{
		proot->inc += increase;
		return;
	}
	proot->nsum += (e - s + 1) * increase;
	insert(proot->pleft, s, e, increase);
	insert(proot->pright, s, e, increase);
}

long long query(Node *proot, int s, int e)
{
	if (s > proot->r || e < proot->l)
		return 0;
	s = max(s, proot->l);
	e = min(e, proot->r);
	if (proot->l == s && proot->r == e)
		return proot->nsum + proot->inc * (proot->r - proot->l + 1);
	long long inc_value = proot->inc * (e - s + 1);
	return query(proot->pleft, s, e) + query(proot->pright, s, e) + inc_value;
}


./README.md
./graph theory
./graph theory/dijkstra_matrix.cpp
int vis[maxn];
int cost[maxn][maxn];
int lowcost[maxn];
int n;

void dijkstra(int beg)
{
	int i, j, min;
	memset(vis, 0, sizeof(vis));
	vis[beg] = 1;
	for (i = 0; i < n; i++)
		lowcost[i] = cost[beg][i];
	lowcost[beg] = 0;
	int pre = beg;
	for (i = 1; i < n; i++)
	{
		min = inf;
		for (j = 0; j < n; j++)
			if (vis[j] == 0 && lowcost[pre] + cost[pre][j] < lowcost[j])
				lowcost[j] = lowcost[pre] + cost[pre][j];
		for (j = 0; j < n; j++)
			if (vis[j] == 0 && lowcost[j] < min)
			{
				min = lowcost[j];
				pre = j;
			}
		vis[pre] = 1;
	}
}
./graph theory/floyd.cpp
int dist[MAX_NODE_NUM][MAX_NODE_NUM];
int node_num;

void init()
{
	memset(dist, -1, sizeof(dist));
}

void floyd()
{
	for (int i = 0; i < node_num; i++)
	{
		for (int j = 0; j < node_num; j++)
		{
			if (dist[j][i] == -1)
				continue;
			for (int k = 0; k < node_num; k++)
			{
				if (dist[i][k] == -1)
					continue;
				if (dist[j][k] == -1 || dist[j][k] > dist[j][i] + dist[i][k])
					dist[j][k] = dist[j][i] + dist[i][k];
			}
		}
	}
}
./graph theory/dfn.cpp
void dfs(int u, int parent)
{
    dfn[u][0] = ++dfn_cnt;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if (v != parent)
        {
            dfs(v, u);
        }
    }
    dfn[u][1] = dfn_cnt;
}
./graph theory/SPFA(vector).cpp
#define MAX_NODE_NUM 105
#define INF 0x3f3f3f3f

int node_num, edge_num;
long long dist[MAX_NODE_NUM];
vector<pair<int, int> > edge[MAX_NODE_NUM];
int push_cnt[MAX_NODE_NUM];
bool in_queue[MAX_NODE_NUM];

bool relax(int &dist, int length)
{
	if (dist > length)
	{
		dist = length;
		return true;
	}
	return false;
}

int SPFA(int origin, int destination)
{
	fill(dist, dist + node_num, INF);
	fill(push_cnt, push_cnt + node_num, 0);
	fill(in_queue, in_queue + node_num, 0);
	queue<int> q;
	q.push(origin);
	in_queue[origin] = true;
	dist[origin] = 0;
	bool unbound = false;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		in_queue[u] = false;
		for (int i = 0; i < edge[u].size(); i++)
		{
			int v = edge[u][i].first;
			int w = edge[u][i].second;
			if (relax(dist[v], dist[u] + w) && !in_queue[v]) 
			{
				q.push(i->v);
				in_queue[i->v] = true;
				push_cnt[i->v]++;
				if (push_cnt[i->v] > node_num)
				{
					return -1;		//negative ring;
				}
			}
		}
	}
	return dist[destination];
}

./graph theory/dijkstra_Edge.cpp
struct Edge
{
	int v, next;
	long long w;
	Edge()
	{}
	Edge(int v, int next, long long w):v(v), next(next), w(w)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
int node_num, edge_num;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int w)
{
	edge[edge_cnt] = Edge(v, head[u], w);
	head[u] = edge_cnt++;
}


bool vis[MAX_NODE_NUM];
long long dist[MAX_NODE_NUM];

void dijkstra(int source)
{
	memset(vis, 0, sizeof(vis));
	fill(dist, dist + node_num, INF);
	dist[source] = 0;
	while (true)
	{
		int min_dist = INF;
		int min_node = -1;

		for (int i = 0; i < node_num; i++)
		{
			if (!vis[i] && dist[i] < min_dist)
			{
				min_dist = dist[i];
				min_node = i;
			}
		}
		if (min_node == -1)
		{
			break;
		}
		vis[min_node] = true;
		for (int i = head[min_node]; i!= -1; i = edge[i].next)
		{
			int v = edge[i].v;
			int w = edge[i].w;
			dist[v] = min(dist[min_node] + w, dist[v]);
		}
	}
}
./graph theory/graph(vector).cpp
int node_num, edge_num;
long long dist[MAX_NODE_NUM];
vector<pair<int, int> > edge[MAX_NODE_NUM];

	edge[u].push_back(make_pair(v, w));
./graph theory/topological_order.cpp
vector<int> edge[MAX_N];
int degree[MAX_N];

void add_edge(int a, int b)
{
	edge[a].push_back(b);
	degree[b]++;
}

void bfs(int node_num, vector<int> edge[])
{
	//indexes start from 0
	queue<int> q;
	for (int i = 0; i < node_num; i++)
	{
		if (degree[i] == 0)
		{
			q.push(i);
		}
	}
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		//push u into an array to get the topological order sequence
		for (int i = 0; i < (int)edge[u].size(); i++)
		{
			int v = edge[u][i];
			if (degree[v] == 0)
			{
				continue;
			}
			degree[v]--;
			if (degree[v] == 0)
			{
				q.push(v);
			}
		}
	}
	//if degree[i] != 0 now, it means there is a circle on the connected component with vertex i.
}

./graph theory/dijkstra_Edge_pq.cpp
struct Edge
{
	int v, next;
	long long w;
	Edge()
	{}
	Edge(int v, int next, long long w):v(v), next(next), w(w)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
int node_num, edge_num;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int w)
{
	edge[edge_cnt] = Edge(v, head[u], w);
	head[u] = edge_cnt++;
}


long long dist[MAX_NODE_NUM];
priority_queue<Edge> pq;

void dijkstra(int source)
{
	fill(dist, dist + node_num, INF);
	dist[source] = 0;
	pq.push(Edge(0, -1, 0));
	while (!pq.empty())
	{
		Edge a;
		a = pq.top();
		pq.pop();
		if (dist[a.v] != a.w)
			continue;
		for (int i = head[a.v]; i!= -1; i = edge[i].next)
		{
			int v = edge[i].v;
			long long w = edge[i].w + a.w;
			if (dist[v] > w)
			{
				dist[v] = w;
				pq.push(Edge(v, -1, dist[v]));
			}
		}
	}
}


./graph theory/prim.cpp

#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM 0
#define INF 0x3f3f3f3f

struct Edge
{
	int v, next;
	double w;
	Edge()
	{}
	Edge(int v, int next, double w):v(v), next(next), w(w)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
int node_num, edge_num;
double dist[MAX_NODE_NUM];
bool vis[MAX_NODE_NUM];

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, double w)
{
	edge[edge_cnt] = Edge(v, head[u], w);
	head[u] = edge_cnt++;
}

void input()
{
	init_edge();
	for (int i = 0; i < node_num; i++)
	{
		int a, b;
		double w;
		scanf("%d%d%lf", &a, &b, &w);
		add_edge(a, b, w);
		add_edge(b, a, w);
	}
}

int find_best()
{
	int ret = -1;
	double max_dist = INF;
	for (int i = 0; i < node_num; i++)
	{
		if (!vis[i] && dist[i] < max_dist)
		{
			ret = i;
			max_dist = dist[i];
		}
	}
	return ret;
}

void alter_neighbours(int u)
{
	for (int i = head[u]; ~i; i = edge[i].next)
	{
		int v = edge[i].v;
		double w = edge[i].w;
		dist[v] = min(dist[v], w);
	}
}

double prim(int s)
{
	double ret = 0;
	fill(dist, dist + node_num, INF);
	memset(vis, 0, sizeof(vis));
	dist[0] = 0;
	int cnt = 0;
	while (true)
	{
		int u = find_best();
		if (u == -1)
			break;
		vis[u] = true;
		cnt++;
		ret += dist[u];
		alter_neighbours(u);
	}
	if (cnt < node_num)
		return -1;//if the graph is not connected
	return ret;
}
./graph theory/dijkstra_vector_pq.cpp
#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM 0
#define INF (1LL << 60)

int node_num, edge_num;
long long dist[MAX_NODE_NUM];
vector<pair<int, int> > edge[MAX_NODE_NUM];

void input()
{
	scanf("%d%d", &node_num, &edge_num);
	for (int i = 0; i < edge_num; i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		v--;
		u--;
		edge[u].push_back(make_pair(v, w));
		edge[v].push_back(make_pair(u, w));
	}
}

priority_queue<pair<long long, int> > pq;

void dijkstra(int source)
{
	fill(dist, dist + node_num, INF);
	dist[source] = 0;
	pq.push(make_pair(0LL, 0));
	for (int i = 0; i < node_num; i++)
		if (train[i])
		{
			pq.push(make_pair(-dist[i], i));
		}
	while (!pq.empty())
	{
		int u = pq.top().second;
		long long w = -pq.top().first;
		pq.pop();
		if (dist[u] != w)
			continue;
		for (int i = 0; i < (int)edge[u].size(); i++)
		{
			int v = edge[u][i].first;
			long long new_w = edge[u][i].second + w;
			if (dist[v] >= new_w && train[v])
			{
				train[v] = false;
			}
			if (dist[v] > new_w)
			{
				dist[v] = new_w;
				pq.push(make_pair(-dist[v], v));
			}
		}
	}
}

./graph theory/struct Edge.cpp
#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM 0

struct Edge
{
	int v, next;
	Edge()
	{}
	Edge(int v, int next):v(v), next(next)
	{}
};

struct Graph
{
	int head[MAX_NODE_NUM];
	int edge_cnt;
	Edge edge[MAX_EDGE_NUM];

	void init()
	{
		memset(head, -1, sizeof(head));
		edge_cnt = 0;
	}

	void add(int u, int v)
	{
		edge[edge_cnt] = Edge(v, head[u]);
		head[u] = edge_cnt++;
	}

	int next(int a)
	{
		return edge[a].next;
	}

	int v(int a)
	{
		return edge[a].v;
	}
};
./3d geometry.cpp
#define zero(x) (((x)>0?(x):-(x))<eps)
#define eps 1.0E-8
#define MAX_POINT_NUM 0

int double_cmp(double a)
{
	if (zero(a))
		return 0;
	return a > 0 ? 1 : -1;
}

struct Point
{
	double x, y, z;

	Point()
	{}

	Point(double x, double y, double z): x(x), y(y), z(z)
	{}

	Point operator - (const Point &a) const
	{
		return Point(x - a.x, y - a.y, z - a.z);
	}

	Point operator + (const Point &a) const
	{
		return Point(x + a.x, y + a.y, z + a.z);
	}

	bool operator == (const Point &a) const
	{
		return !double_cmp(x - a.x) && !double_cmp(y - a.y) && !double_cmp(z - a.z);
	}
};

double dot_product(Point a, Point b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

double point_dist(Point a)
{
	return a.x * a.x + a.y * a.y + a.z * a.z;
}
./combinatorial math
./combinatorial math/bit_enumerate.cpp
	for (int i = 1; i < (1 << bit_num); i++)
	{
		//i is the 01-bits sequence
		for (int j = 0; (i >> j) > 0; j++)
		{
			if ((i >> j) & 1)
			{
				//the j-th bit is 1
			}
		}
	}

./computational geometry.cpp
#define zero(x) (((x)>0?(x):-(x))<eps)
#define eps 1.0E-8
#define MAX_POINT_NUM 0

int double_cmp(double a)
{
	if (zero(a))
		return 0;
	return a > 0 ? 1 : -1;
}

struct Point
{
	double	x,y;
	Point()
	{}
	Point(double x, double y):x(x), y(y)
	{}
	Point operator - (Point &a)
	{
		return Point(x - a.x, y - a.y);
	}	
	bool operator <(const Point &a)const
	{
	    return atan2(y, x) < atan2(a.y, a.x);
	}
	bool operator == (const Point &a) const
	{
		return x == a.x && y == a.y;
	}
};

double cross_product(Point a, Point b)
{
	return a.x * b.y - b.x * a.y;
}

double cross_product(Point p0, Point p1, Point p2)
{
	return cross_product(p1 - p0, p2 - p0);
}

double dot_product(Point a, Point b)
{
	return a.x * b.x + a.y * b.y;
}

double dot_product(Point p0, Point p1, Point p2)
{
	return dot_product(p1 - p0, p2 - p0);
}

double point_dist(Point a)
{
	return sqrt(a.x * a.x + a.y * a.y);
}

double point_dist(Point a, Point b)
{
	return point_dist(a - b);
}

struct Line
{
	Point a, b;
	Line()
	{}
	Line(Point a, Point b):a(a), b(b)
	{}	
	bool operator == (const Line &l) const
	{
		return l.a == a && l.b == b;
	}
};

bool points_inline(Point p1, Point p2, Point p3)
{
	return zero(cross_product(p1, p2, p3));
}

bool same_side(Point p1, Point p2, Line l)
{
	return double_cmp(cross_product(l.a, p1, l.b) * cross_product(l.a, p2, l.b)) > 0;
}

bool point_online_inclusive(Point p, Line l)
{
	return double_cmp(zero(cross_product(p, l.a, l.b)) && dot_product(p, l.a, l.b)) <= 0;
}

bool point_online_exclusive(Point p, Line l)
{
	return zero(cross_product(p, l.a, l.b)) && double_cmp(dot_product(p, l.a, l.b)) < 0;
}

bool overlap_exclusive(Line u, Line v)
{
	if (u == v || (u.a == v.b && u.b == v.a))
		return true;
	if (!points_inline(u.a, u.b, v.a) || !points_inline(u.a, u.b, v.b))
		return false;
	bool ret = point_online_exclusive(u.a, v);
	ret = ret || point_online_exclusive(u.b, v);
	ret = ret || point_online_exclusive(v.a, u);
	ret = ret || point_online_exclusive(v.b, u);
	return ret;
}

bool intersect_inclusive(Line u, Line v)
{
	if (!points_inline(u.a, u.b, v.a) || !points_inline(u.a, u.b, v.b))
		return !same_side(u.a, u.b, v) && !same_side(v.a, v.b, u);
	bool ret = point_online_inclusive(u.a, v);
	ret = ret || point_online_inclusive(u.b, v);
	ret = ret || point_online_inclusive(v.a, u);
	ret = ret || point_online_inclusive(v.b, u);
	return ret;
}

double line_length(Line l)
{
	return point_dist(l.a - l.b);
}

double point_line_dist(Point a, Line l)
{
	return abs(cross_product(l.a - a, l.b - a) / line_length(l));
}

Point intersection_point(Line l1,Line l2)
{
    double s1 = cross_product(l1.a, l1.b, l2.a);
    double s2 = cross_product(l1.a, l1.b, l2.b);
    Point ret;
    ret.x = (s1 * l2.b.x - s2 * l2.a.x) / (s1 - s2);
    ret.y = (s1 * l2.b.y - s2 * l2.a.y) / (s1 - s2);
    return ret;
}

struct Polygon
{
	Point point[MAX_POINT_NUM];
	int point_num;
};

bool convex(Polygon &a) //point should be counter-clockwise
{
	for (int i = 0; i < a.point_num; i++)
	{
		Point p1 = a.point[(i + 1) % a.point_num] - a.point[i];
		Point p2 = a.point[(i + 2) % a.point_num] - a.point[(i + 1) % a.point_num];
		if (double_cmp(cross_product(p1, p2)) < 0)
			return false;
	}
	return true;
}

bool point_in_convex(Polygon &a, Point peg) //point should be counter-clockwise
{
	for (int i = 0; i < a.point_num; i++)
	{
		Point p1 = a.point[(i + 1) % a.point_num] - a.point[i];
		Point p2 = peg - a.point[(i + 1) % a.point_num];
		if (double_cmp(cross_product(p1, p2)) <= 0)
			return false;
	}
	return true;
}
./binary_search.cpp
int binary_search(int start, int end, int a)
{
	int l = start;
	int r = end;
	while (l < r)
	{
		int mid = (l + r) / 2;
		if (ok(mid, a))
			r = mid;
		else
			l = mid + 1;
	}
	return l;
}


./matrix_multiply_pow.cpp
#define MAX_MATRIX_SIZE 101
#define MOD 100000

struct Matrix
{
	int order;
	int num[MAX_MATRIX_SIZE][MAX_MATRIX_SIZE];

	Matrix()
	{}

	Matrix(int ord)
	{
		order = ord;
	}

	void init()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				num[i][j] = 0;
			}
		}
	}
	void output()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				printf("%d ", num[i][j]);
			}
			puts("");
		}
	}
};

Matrix operator*(Matrix ma, Matrix mb)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	int i, j, k;
	for (i = 0; i < ord; i++)
	{
		for (k = 0; k < ord; k++)
		{
			if (ma.num[i][k] == 0)
				continue;
			for (j = 0; j < ord; j++)
			{
				long long temp = ma.num[i][k] * (long long)mb.num[k][j];
				temp %= MOD;
				numc.num[i][j] += temp;
				numc.num[i][j] %= MOD;
			}
		}
	}
	return numc;
}

Matrix matrix_power(Matrix ma, int x)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	for (int i = 0; i < ord; i++)
	{
		numc.num[i][i] = 1;
	}
	for (; x; x >>= 1)
	{
		if (x & 1)
		{
			numc = numc * ma;
		}
		ma = ma * ma;
	}
	return numc;
}
